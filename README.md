# JavaWebFramework
The way to learn the JavaWeb Framework Designer
## 1.多线程与并发导论
### 1.1cache一致性的实现方式：更新协议和作废协议
参考：https://wenku.baidu.com/view/237d380a0912a21614792948.html
Cache: 高速缓冲存储器，为了解决主存与cpu之间的速度不匹配。


    Cache中存储的是主存中的一个副本，程序执行中如果要对该字块进行改写，会遇到如何保持主存与cache一致性的问题。
*     不命中时：直接写入主存
*     命中时： 写回法、写直达法
    写回法：只更新Cache单元并且加以标记，当该块从Cache移出时，再更新相应的主存单元。
    写直达法：Cache与主存同时写，有一段时间主存内容与Cache内容不一致。写直达法能保证数据的正确性但是会增加多次不必要的写主存。



Cache的一致性：
    采用cache的系统中，同样的数据可能存在cache中也可能存在主存中，两者数据相同则具有一致性，反之。如果不能保证数据一致性，会导致接下来的程序出现问题。



解决Cache一致性：
    监听总线协议：采用基于总线的存储结构的并行系统，总线时保证高速缓存一致性的最方便的设备，它允许系统中各个处理机能够检测对存储器的所有操作，每个高速缓存都在监听其他高速缓存，如果发生问题，就可以采取相应的动作维护高速缓存的一致性。
* 写无效策略 
        当任何一个处理机写自己的高速缓存的时候，由它负责将所有的高速混存副本变为无效，导致其他缓存中的副本都是“过时”，根据处理不同还可以分为

1.             写通过   ： 更新主存中的副本，最终Cache中的副本和主存的副本都是有效的，其他副本无效
2.             写回       ：最终主存中的副本也失效，只有Cache中的副本有效 

缺点：无效副本引起缺失造成开销
* 写更新策略
         当任何一个处理机改写Cache时，就改写它所有的副本，使得所有数据块副本几乎都是有效的。
缺点：更新所有副本开销较大。

写一次协议：
结合上面介绍的协议优点：James Goodman 提出基于总线多处理机系统高速缓存一致性协议。思想：高速缓存块的第一次写采用写通过策略，产生一份正确的主存副本，并且使得其它高速缓存副本无效后采取写回策略，其他高速缓存和主存中的副本均无效。

设计与分析协议一致性需要考虑的问题：
* 高速缓存可能出现的状态集
1.         有效（valid）：与主存副本一致的高速缓存副本，该副本未经修改，也不一定是唯一正确的副本，别的高速寄存器中也可能存在该数据块有效的副本。
2.         保留  (reserved)：高速缓存中的副本是第一次被修改，并采用写通过方法写入主存，所以这个高速混存中的副本与主存中一致，系统中有且只有这两个副本有效。
3.         重写  (dirty) ：高速缓存中的副本不止一次被修改过，由于不在采用写通过的方法，所以这个高速缓存中的副本是唯一的有效副本，与主存和其他高速缓存中的副本都不一致，主存中的副本也是无效的。
4.         无效  (invalid) ：与主存中和其他高速缓存中的副本不一致或在高速缓存中根本没有该副本。
* 共享主存的状态
* 为维护一致性而引起的状态转换

存在的问题：
开销大：发无效命令使对应副本编程无效状态的开销；读高速缓存时，由于数据块副本编程无效状态造成读缺失，从其他地方取得数据开销。

扩展性差：发送无效命令时，通常只用共享总线才能提供所需要有效的广播手段，其他高速缓存才能够进行监听，所以这种写一次的应用对象主要是共享总线的并行系统。


    基于目录的协议：对于可扩展多处理机系统，一般采用互联网实现多处理互联，网络没有方便的监听机制，因此难以有效的广播，通常使用这个协议。

基本思想：
    针对协议次协议的开销大、扩展性差的缺陷，提出基于目录的方法，使无效的指令只发给存放特定数据块副本的某些高速缓存。以这种高效的点对点的方式代替广播方式，这种方法在共享总线中可以降低总线带宽的占用，有效的使用在通过交换网络进行通信的并行系统中。

目录：
全映射目录
有限目录
链式目录
### 1.2 jvm多线程内存模型
参考：https://www.jianshu.com/p/a3f9f2c3ecf8
#### JVM的内部的内存模型分为了两部分，thread stack和heap
每一个jvm中的线程都有一个线程栈，且包含线程方法的执行信息，调用栈会随着执行的状态改变。它包括了所有的方法和local变量，线程只能访问自己的线程栈，本地变量是私有的。线程栈之间变量不能共享只能传递拷贝。new出来的对象不管是分配本地变量还是成员变量，最终都是存在堆内。

存储在堆上的对象可以被所有线程所引用和访问，当一个线程持有一个对象的引用，即可以访问它的成员变量。

